---
layout: /src/layouts/MarkdownPostLayout.astro
title: 线程池参数设定过大的影响
description: 线程池参数设定过大的影响
pubDate: 2025-04-20
---
## 最大线程数和核心线程数设定过大的影响
### 下文切换开销

当活跃线程数远超 CPU 核心数时，每个线程执行时间片被大幅缩减，系统在调度线程之间频繁切换，消耗大量 CPU 周期而非执行业务逻辑，导致整体吞吐量和响应时延双双恶化 

### 资源竞争与锁争用

大量并发线程在共享数据结构或锁上激烈争用，频繁出现线程阻塞和唤醒，进一步加剧上下文切换，并可能导致缓存行抖动（cache thrashing），削弱多核优势 

### 内存占用与 OOM

每创建一个线程，JVM 通常会为其分配约 1MB 的本地栈空间，如果线程数设为数万甚至更高，就会迅速耗尽系统内存或本地内存配额，引发 `OutOfMemoryError` 

### 垃圾回收压力

线程对象的不断创建与销毁，以及由此产生的附属对象（如任务包装器），都会增加 JVM 对堆内存的扫描与整理成本，可能触发频繁的全量 GC 或 GC 长时间停顿 

### 线程泄露

默认情况下，`corePoolSize` 内的线程不会超时回收；若该值设得过大且未启用 `allowCoreThreadTimeOut(true)`，将导致大批空闲线程长期驻留并占用资源，增加系统不稳定风险 

### 队列与拒绝策略失效

即使配合合理的阻塞队列和拒绝策略，当最大线程数过大时，队列很可能先于达到 `maximumPoolSize` 而被填满，使得拒绝策略或降级方案迟迟得不到触发，破坏系统平滑降级能力 

## 队列过长的主要影响
### 1. 内存溢出 (OOM)

使用无界队列会让待执行任务不断累积，最终耗尽内存并抛出 `OutOfMemoryError` 

### 2. 垃圾回收压力增大

大量堆积的任务对象会占用堆内存，触发频繁的 GC，严重时会出现 “GC overhead limit exceeded”

### 3. 系统吞吐量下降与高延迟

任务堆积在线程池队列中时，新任务无法及时执行，导致整体吞吐量下降、响应时延显著增加 

### 4. 最大线程数失效与拒绝策略失灵

当队列容量巨大或使用无界队列时，线程数只会达到 `corePoolSize` 而不会扩展至 `maximumPoolSize`，导致拒绝策略永远不被触发

### 5. 任务饥饿死锁

若队列内的任务相互依赖（如 A 任务等待 B 任务结果），大量任务排队会造成线程饥饿死锁，线程池无法分配足够线程解决依赖
