---
layout: /src/layouts/MarkdownPostLayout.astro
title: 优惠项目相关
description: 优惠项目相关
pubDate: 2025-04-20
---

## 一人一单具体如何实现

本项目采用了 Redis+Lua脚本 、数据库唯一索引 实现一人一单，在用户发起秒杀请求时，首先通过Lua脚本在Redis中原子性判断该用户是否已经下过单（利用 SISMEMBER 判断用户ID是否存在于订单集合中），如果存在则直接返回，防止重复下单。在消息队列消费者（ `receiveSeckillMessage` ）中，落库前再次通过数据库查询是否已存在该用户的订单，防止极端情况下的重复下单。数据库层面在订单表（如 tb_voucher_order ）设置了 (user_id, voucher_id) 唯一索引，作为最终防线。
## 如何保证数据一致性
使用 Cache Aside 策略，先更新数据库，再删除缓存
数据库事务 ：在MQ消费者中，扣减库存和保存订单操作放在同一个事务中，保证原子性。
## 如何保证不超卖
项目通过 Redis+Lua脚本原子操作 和 数据库乐观锁 双重机制防止超卖：

- Redis层 ：Lua脚本中先判断库存是否大于0，再进行扣减，整个过程是原子操作，防止并发超卖。
- 数据库层 ：在MQ消费者中，扣减库存时使用 where voucher_id = ? and stock > 0 ，只有库存大于0时才会扣减成功，防止极端情况下的超卖（见 `receiveSeckillMessage` ）。

## Redis集群模式下能否保证不超卖
理论上存在风险 。Lua脚本在Redis集群模式下只能保证同一个slot内的key原子性，如果库存key和订单key不在同一个slot，Lua脚本无法跨slot原子执行，可能导致并发下超卖。

- 解决方案 ：可以通过hash tag（如 seckill:{voucherId}:stock 和 seckill:{voucherId}:order ）保证相关key落在同一个slot，从而保证Lua脚本的原子性。
- 更保险的做法 ：在集群环境下，建议引入分布式锁（如Redisson）或将关键业务逻辑下沉到数据库层（如乐观锁、唯一索引）作为最终保障。