---
layout: /src/layouts/MarkdownPostLayout.astro
title: HashMap的实现原理
description: HashMap的实现原理
pubDate: 2025-04-18
---
Java 8 及以上版本的 `HashMap` 底层维护一个 `Node<K,V>[] table` 数组，索引通过 `key.hashCode() & (table.length-1)` 计算得到；当单个桶中元素过多（>8）时，链表会“树化”为红黑树以降低查找复杂度，否则以链表存储

1. 当我们往HashMap中put元素时，利用key的hashCode重新hash计算出当前对象的元素在数组中的下标
    
2. 存储时，如果出现hash值相同的key，此时有两种情况。
    

a. 如果key相同，则覆盖原始值；

b. 如果key不同（出现冲突），则将当前的key-value放入链表或红黑树中

3. 获取时，直接找到hash值对应的下标，在进一步判断key是否相同，从而找到对应值。


**面试官追问：HashMap的jdk1.7和jdk1.8有什么区别**

- JDK1.8之前采用的是拉链法。拉链法：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。
    
- jdk1.8在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8） 时并且数组长度达到64时，将链表转化为红黑树，以减少搜索时间。扩容 resize( ) 时，红黑树拆分成的树的结点数小于等于临界值6个，则退化成链表

红黑树是一种自平衡二叉搜索树，查找、插入、删除均为 O(log n)，而链表最坏查找需遍历为 O(n)。当链表过长时，红黑树能显著降低查询延迟

### 当链表长度很小（如 <8）时，为什么使用链表优于树？
当桶内元素较少（默认阈值小于 8）时，**链表的插入和遍历**在节点数很少的情况下开销更低，不需要额外的旋转、染色等平衡操作   
而将链表转换为红黑树需要创建 `TreeNode`、执行多次旋转与重染色，**单次转换成本较高**，只有当冲突严重、查询次数很多时才体现出 O(log n) 的优势