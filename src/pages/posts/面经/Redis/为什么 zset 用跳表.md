---
layout: /src/layouts/MarkdownPostLayout.astro
title: 为什么 zset 用跳表
description: 为什么 zset 用跳表
pubDate: 2025-04-26
---
- **内存友好**：跳表基于链表，通过多级索引加速查询，**内存访问模式更符合CPU缓存局部性**（指针跳跃更少）。
- **简单灵活**：插入/删除时仅需调整局部指针，无需复杂的节点分裂与合并。
- 跳表实现简单


- **从内存占用上来比较，跳表比平衡树更灵活一些**。平衡树每个节点包含 2 个指针（分别指向左右子树），而跳表每个节点包含的指针数目平均为 1/(1-p)，具体取决于参数 p 的大小。如果像 Redis里的实现一样，取 p=1/4，那么平均每个节点包含 1.33 个指针，比平衡树更有优势。
- **在做范围查找的时候，跳表比平衡树操作要简单**。在平衡树上，我们找到指定范围的小值之后，还需要以中序遍历的顺序继续寻找其它不超过大值的节点。如果不对平衡树进行一定的改造，这里的中序遍历并不容易实现。而在跳表上进行范围查找就非常简单，只需要在找到小值之后，对第 1 层链表进行若干步的遍历就可以实现。
- **从算法实现难度上来比较，跳表比平衡树要简单得多**。平衡树的插入和删除操作可能引发子树的调整，逻辑复杂，而跳表的插入和删除只需要修改相邻节点的指针，操作简单又快速。

## ZSet 除了跳表，还有其他底层格式吗

- **跳表 + 哈希表**：常规大规模有序集。
    
- **压缩列表/列表打包（ziplist/listpack）**：当成员数或成员长度小于阈值时，用于节省内存，但查询 O(n)。
