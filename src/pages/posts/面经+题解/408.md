---
layout: /src/layouts/MarkdownPostLayout.astro
title: "408"
description: 408相关的面试题
pubDate: 2025-04-28
---
## TCP 协议的状态

TCP 连接状态共 11 种：`LISTEN`、`SYN-SENT`、`SYN-RECEIVED`、`ESTABLISHED`、`FIN-WAIT-1`、`FIN-WAIT-2`、`CLOSE-WAIT`、`CLOSING`、`LAST-ACK`、`TIME-WAIT`、`CLOSED`。

## 握手/挥手的初始序列号是多少，如何生成的

- **初始序列号（ISN）**：三次握手时客户端/服务端分别生成随机 32 位数作为 ISN，避免安全风险。 
    
- **生成方式**：遵循 RFC 6528，以加密安全的伪随机数生成器产生。

## TCP 握手时，还交换了哪些信息

除 SYN/ACK/ACK 标志和序列号外，还交换**窗口大小**（advertised window）用于流量控制。

## TCP 头部字段与选项

- **字段**：源端口、目的端口、序列号、确认号、数据偏移、保留位、控制位（URG/ACK/PSH/RST/SYN/FIN）、窗口、校验和、紧急指针、选项、填充。 
- **常见选项**：最大报文段长度（MSS）、窗口缩放（Window Scale）、SACK 可选、时间戳（Timestamps）。

## 访问网页的全过程
简单过一遍完整流程：
1. 在浏览器中输入指定网页的 URL。
2. 浏览器通过 DNS 协议，获取域名对应的 IP 地址。
3. 浏览器根据 IP 地址和端口号，向目标服务器发起一个 TCP 连接请求。
4. 浏览器在 TCP 连接上，向服务器发送一个 HTTP 请求报文，请求获取网页的内容。
5. 服务器收到 HTTP 请求报文后，处理请求，并返回 HTTP 响应报文给浏览器。
6. 浏览器收到 HTTP 响应报文后，解析响应体中的 HTML 代码，渲染网页的结构和样式，同时根据 HTML 中的其他资源的 URL（如图片、CSS、JS 等），再次发起 HTTP 请求，获取这些资源的内容，直到网页完全加载显示。
7. 浏览器在不需要和服务器通信时，可以主动关闭 TCP 连接，或者等待服务器的关闭请求。
## 内核态和用户态

>一、内核态、用户态概念

内核态：也叫内核空间，是内核进程/线程所在的区域。主要负责运行系统、硬件交互。

用户态：也叫用户空间，是用户进程/线程所在的区域。主要用于执行用户程序。

> 二、内核态和用户态的区别

内核态：运行的代码不受任何限制，CPU可以执行任何指令。

用户态：运行的代码需要受到CPU的很多检查，不能直接访问内核数据和程序，也就是说不可以像内核态线程一样访问任何有效地址。

操作系统在执行用户程序时，主要工作在用户态，只有在其执行没有权限完成的任务时才会切换到内核态。

> 三、为什么要区分内核态和用户态

保护机制。防止用户进程误操作或者是恶意破坏系统。内核态类似于C++的私有成员，只能在类内访问，用户态类似于公有成员，可以随意访问。

> 四、用户态切换到内核态的方式

1. 系统调用（主动）

由于用户态无法完成某些任务，用户态会请求切换到内核态，内核态通过为用户专门开放的中断完成切换。

2. 异常（被动）

在执行用户程序时出现某些不可知的异常，会从用户程序切换到内核中处理该异常的程序，也就是切换到了内核态。

3. 外围设备中断（被动）

外围设备发出中断信号，当中断发生后，当前运行的进程暂停运行，并由操作系统内核对中断进程处理，如果中断之前CPU执行的是用户态程序，就相当于从用户态向内核态的切换。
## 为什么网络要分层
1. 「各层之间相互独立」：各层之间相互独立，各层之间不需要关心其他层是如何实现的，只需要知道自己如何调用下层提供好的功能就可以了（可以简单理解为接口调用）。「这个和我们对开发时系统进行分层是一个道理。」
    
2. 「提高了整体灵活性」 ：每一层都可以使用最适合的技术来实现，你只需要保证你提供的功能以及暴露的接口的规则没有改变就行了。「这个和我们平时开发系统的时候要求的高内聚、低耦合的原则也是可以对应上的。」
    
3. 「大问题化小」 ：分层可以将复杂的网络间题分解为许多比较小的、界线比较清晰简单的小问题来处理和解决。这样使得复杂的计算机网络系统变得易于设计，实现和标准化。 「这个和我们平时开发的时候，一般会将系统功能分解，然后将复杂的问题分解为容易理解的更小的问题是相对应的，这些较小的问题具有更好的边界（目标和接口）定义。」

## HTTPS的执行流程

 >客户端发起TLS握手请求（Client Hello）
 
 客户端发送`Client Hello`消息，包含支持的TLS版本、加密套件列表（如AES、RSA）、压缩算法及一个随机数（Client Random）
 
> 服务器响应（Server Hello）

服务器返回`Server Hello`消息，确认使用的TLS版本、加密套件、压缩算法，并发送一个随机数（Server Random）和数字证书

> 证书验证​

客户端验证服务器证书的有效性，包括：
- 证书是否由受信任的CA颁发
- 证书是否过期或被吊销
- 域名是否匹配
若验证失败，连接终止；若通过，客户端生成​**​预主密钥​**​（Pre-Master Secret）

>​密钥交换​​

非对称加密传递预主密钥​​：客户端用服务器公钥加密预主密钥并发送给服务器

> 生成会话密钥

客户端与服务器基于Client Random、Server Random和预主密钥，通过算法生成​​对称会话密钥​（Session Key）

## next
